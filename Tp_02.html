<!DOCTYPE html>
<html>
<head>
  <title>CG_TP02-Denis/Helder/Nelson</title>
  <div id="blocker">
    <div id="instructions">
      <span id="title" style="font-size:50px">Click to start</span>
      <br/>Se acertar no alvo ganha a bala de volta e o jogo acaba automaticamente se ficar sem balas<br/>
      <br/>Teclas :
      <br/>W, A, S, D = Mover
      <br/>Rato lado esquerdo = Disparar
      <br/>Esc = Pausa
    </div>
  </div>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      cursor: none;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    #instructions {
      width: 100%;
      height: 100%;
      display: -webkit-box;
      display: -moz-box;
      -webkit-box-orient: horizontal;
      -moz-box-orient: horizontal;
      box-orient: horizontal;
      -webkit-box-pack: center;
      -moz-box-pack: center;
      box-pack: center;
      -webkit-box-align: center;
      -moz-box-align: center;
      box-align: center;
      color: #ffffff;
      text-align: center;
      cursor: pointer;
    }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/96/three.min.js"></script>
<script type="text/javascript" src="js/jquery-1.9.0.js"></script>
<script type="text/javascript" src="js/Stats.js"></script>
<script type="text/javascript" src="js/dat.gui.js"></script>
<script type="text/javascript" src="js/PointerLockControls.js"></script>
<script type="text/javascript" src="js/OBJLoader.js"></script>
<script type="text/javascript" src="js/MTLLoader.js"></script>
<script type="text/javascript" src="js/physi.js"></script>
<script type="text/javascript" src="js/howler.js"></script>
<script>

  //Class Object
  class Obj {
    constructor() {
      this.mesh;
      this.inc = 1;
    }

    getMesh() {
      return this.mesh;
    }
  }

  //Class Cube
  class Cube extends Obj {
    constructor(size, position) {
      super();
      this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
      this.material = new THREE.MeshLambertMaterial({color: 0x00ff00});
      this.mesh = new Physijs.BoxMesh(this.geometry, this.material);
      this.mesh.castShadow = true;
      this.mesh.position.x = position.x;
      this.mesh.position.y = position.y;
      this.mesh.position.z = position.z;

    }

    update() {
    }
  }

  //Class Straw
  class CubeTexture extends Cube {
    constructor(size, position, rotation) {
      super(size, position);
      this.geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
      this.tableMaterials =
        [
          new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('img/straw3.png'), side: THREE.DoubleSide}), //Right Side
          new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('img/straw3.png'), side: THREE.DoubleSide}), //Left Side
          new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('img/straw1.png'), side: THREE.DoubleSide}), //Top Side
          new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('img/straw1.png'), side: THREE.DoubleSide}), //Bottom Side
          new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('img/straw2.png'), side: THREE.DoubleSide}), //Front Side
          new THREE.MeshPhongMaterial({map: new THREE.TextureLoader().load('img/straw2.png'), side: THREE.DoubleSide}), //Back Side
        ];
      this.material = new THREE.MeshFaceMaterial(this.tableMaterials);
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.castShadow = true;
      this.mesh.position.x = position.x;
      this.mesh.position.y = position.y;
      this.mesh.position.z = position.z;
      this.mesh.rotation.y = rotation.y;
    }
  }

  //Class Fence
  class Fence extends Obj {
    constructor(position, rotation) {
      super();
      let woodMaterial = new THREE.MeshPhongMaterial({
        map: new THREE.TextureLoader().load('img/wood2.jpg'),
        side: THREE.DoubleSide
      })
      let woodMaterial2 = new THREE.MeshPhongMaterial({
        map: new THREE.TextureLoader().load('img/wood3.jpg'),
        side: THREE.DoubleSide
      })
      let woodMaterial3 = new THREE.MeshPhongMaterial({
        map: new THREE.TextureLoader().load('img/wood4.jpg'),
        side: THREE.DoubleSide
      })
      this.mesh = new THREE.Group()
      let geometry = new THREE.CylinderGeometry(3, 3, 10);
      let material = woodMaterial;
      let cylinder = new Physijs.BoxMesh(geometry, material);
      cylinder.scale.set(0.2, 2.08, 0.2);
      cylinder.position.set(-5.5, 0, 0);
      cylinder.castShadow = true;
      this.mesh.add(cylinder);
      geometry = new THREE.CylinderGeometry(3, 3, 10);
      cylinder = new Physijs.BoxMesh(geometry, material);
      cylinder.scale.set(0.2, 2.08, 0.2);
      cylinder.position.set(5.5, 0, 0);
      cylinder.castShadow = true;
      this.mesh.add(cylinder);
      geometry = new THREE.BoxGeometry(10.62, 1, 0.08);
      let cube = new Physijs.BoxMesh(geometry, woodMaterial2);
      cube.position.set(0, 8.659, 0);
      cube.castShadow = true;
      this.mesh.add(cube);
      geometry = new THREE.BoxGeometry(10.62, 1, 0.08);
      let cube1 = new Physijs.BoxMesh(geometry, woodMaterial3);
      cube1.position.set(0, 4, 0);
      cube1.castShadow = true;
      this.mesh.add(cube1);
      this.mesh.position.x = position.x;
      this.mesh.position.y = position.y;
      this.mesh.position.z = position.z;
      this.mesh.rotation.y = rotation.y;
    }

    update() {
    }
  }


  //Class Tree
  class Tree extends Obj {
    constructor(position) {
      super();
      this.material = new THREE.MeshPhongMaterial({
        map: new THREE.TextureLoader().load('img/treetext.jpg'),
        side: THREE.DoubleSide
      })
      this.trunkMaterial = new THREE.MeshPhongMaterial({
        map: new THREE.TextureLoader().load('img/wood1.jpg'),
        side: THREE.DoubleSide
      })
      this.mesh = new THREE.Group()
      //First Cone
      const level1 = new THREE.Mesh(
        new THREE.ConeGeometry(3, 6, 100),
        this.material
      )
      level1.position.y = 45
      level1.castShadow = true;
      //Second Cone
      const level2 = new THREE.Mesh(
        new THREE.ConeGeometry(4, 7, 100),
        this.material
      )
      level2.position.y = 42
      level2.castShadow = true;
      //Third Cone
      const level3 = new THREE.Mesh(
        new THREE.ConeGeometry(6, 12, 100),
        this.material
      )
      level3.position.y = 38
      level3.castShadow = true;
      //Fort Cone
      const level4 = new THREE.Mesh(
        new THREE.ConeGeometry(8, 15, 100),
        this.material
      )
      level4.position.y = 32
      level4.castShadow = true;
      //Fifth Cone
      const level5 = new THREE.Mesh(
        new THREE.ConeGeometry(10, 19, 100),
        this.material
      )
      level5.position.y = 26
      level5.castShadow = true;
      //Trunk
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(1.5, 1.5, 40),
        this.trunkMaterial
      )
      trunk.castShadow = true;
      this.mesh.add(level1)
      this.mesh.add(level2)
      this.mesh.add(level3)
      this.mesh.add(level4)
      this.mesh.add(level5)
      this.mesh.add(trunk)
      this.mesh.position.x = position.x;
      this.mesh.position.y = position.y;
      this.mesh.position.z = position.z;
    }

    update() {
    }
  }


  //Class Person
  class Person {
    constructor(camera, scene) {
      let mat = Physijs.createMaterial(new THREE.MeshPhongMaterial({color: 0x000000}), 1, 0);
      this.Person = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), mat);
      this.Person.material.transparent = false;
      this.Person.material.opacity = 0.0;
      this.Person.position.y = 2.5;
      this.Person.__dirtyPosition = true;
      scene.add(this.Person);
      this.controls = controls;
      this.activeWeapon = null;
      this.posLimite = 82;
      this.rifle = null;
      this.Person.add(camera);
    }

    updateControls() {
      controls.getObject().position.set(this.Person.position.x, this.Person.position.y + 5, this.Person.position.z);
    }

    getPosition() {
      let pos = new THREE.Vector3();
      pos.x = this.Person.position.x;
      pos.y = this.Person.position.y;
      pos.z = this.Person.position.z;
      return pos;
    }

    setInitialPosition() {
      this.Person.position.set(0, 2.5, 0);
    }

    getActiveWeapon() {
      return this.activeWeapon;
    }

    moveForward() {
      let target = camera.getWorldDirection();
      let nextPosition = target.x + this.Person.position.x;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateX(target.x);
      nextPosition = target.z + this.Person.position.z;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateZ(target.z);
    }

    moveBackward() {
      let target = camera.getWorldDirection();
      let nextPosition = -target.x + this.Person.position.x;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateX(-target.x);
      nextPosition = -target.z + this.Person.position.z;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateZ(-target.z);
    }

    moveLeft() {
      let target = camera.getWorldDirection();
      let nextPosition = target.z + this.Person.position.x;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateX(target.z);
      nextPosition = -target.x + this.Person.position.z;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateZ(-target.x);
    }

    moveRight() {
      let target = camera.getWorldDirection();
      let nextPosition = -target.z + this.Person.position.x;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateX(-target.z);
      nextPosition = target.x + this.Person.position.z;
      if (nextPosition <= this.posLimite && nextPosition >= -this.posLimite)
        this.Person.translateZ(target.x);
    }

    animateWeapon() {
      if (this.activeWeapon == 0) {
        shooting = false;
      }
    }

    loadWeapons() {

      let that = this;
      let mtlLoader = new THREE.MTLLoader();
      let objLoader = new THREE.OBJLoader();
      let texture = null;
      mtlLoader.setPath("models/");
      mtlLoader.load("material.mtl", function (materials) {
        materials.preload();
        objLoader.setMaterials(materials);
        objLoader.setPath("models/");
        objLoader.load("m4a1_s.obj", function (object) {
          texture = THREE.ImageUtils.loadTexture('models/m4a1_stext.png');
          object.children[1].material = new THREE.MeshLambertMaterial({map: texture});
          object.children[1].scale.set(0.3, 0.3, 0.3);
          object.children[1].rotation.set(0, 3.2, 0);
          object.children[1].position.set(-0.7, -3, 0);
          that.rifle = object.children[1];
          camera.add(that.rifle);
          that.activeWeapon = 0;
        });
      });
    }
  }

  //Class Bullets
  class Bullets {
    constructor(maxBullets, scene, aMaterial) {
      this.material = aMaterial;
      this.objWidth = 1;
      this.maxBullets = maxBullets;
      this.bullets = [];
      this.launched = [];
      this.target = [];
      for (let i = 0; i < maxBullets; ++i) {
        this.launched[i] = false;
        this.target[i] = new THREE.Vector3(0, 0, 0);
        this.bullets[i] = this.createObject(i);
        scene.add(this.bullets[i]);
      }
    }

    getParameters(i) {
      let parameters = {
        x: this.bullets[i].position.x, y: this.bullets[i].position.y,
        z: this.bullets[i].position.z, radio: this.objWidth / 2
      };
      return parameters;
    }

    reload() {
      for (let i = 0; i < this.maxBullets; ++i) {
        this.bullets[i].remove();
        this.launched[i] = false;
        this.target[i] = new THREE.Vector3(0, 0, 0);
        this.bullets[i] = this.createObject(i);
        scene.add(this.bullets[i]);
      }
    }

    createObject(i) {
      let bullet = new Physijs.SphereMesh(new THREE.SphereGeometry(this.objWidth / 4, 20, 20), this.material, 50);
      bullet.position.set(i, -9.5, 0.0);
      bullet.castShadow = true;
      return bullet;
    }

    shoot(i, position, target, weapon) {
      this.target[i].set(target.x, target.y, target.z);
      this.bullets[i].position.set(position.x - target.x, position.y + 5, position.z - target.z);
      this.bullets[i].setCcdMotionThreshold(10);
      this.bullets[i].setCcdSweptSphereRadius(this.objWidth / 4);
      this.bullets[i].__dirtyPosition = true;
      this.launched[i] = true;
      let power = null;
      let sound = null;
      if (weapon == 0) {
        power = 35000;
        sound = new Howl({
          src: ['sounds/m4a1_s.mp3'], volume: 0.1
        });
      }
      let force = new THREE.Vector3(this.target[i].x * power, this.target[i].y * power, this.target[i].z * power);
      this.bullets[i].applyCentralImpulse(force);
      sound.play();
    }
  }

  //Class Enemies
  class Enemies {
    constructor(scene, level) {
      this.enemies = [];
      this.countCollisions = [];
      this.direction = [];
      this.force = 0;
      this.init = true;
      this.countDead = 0;
      this.scene = scene;

      if (level == 1)
        this.force = 5;
      else if (level == 2)
        this.force = 10;
      else if (level == 3)
        this.force = 20;
      else if (level == 4)
        this.force = 30;
      else if (level == 5)
        this.force = 50;
      else if (level == 6)
        this.force = 70;
      else if (level == 7)
        this.force = 90;
      else if (level == 8)
        this.force = 100;
      else if (level == 9)
        this.force = 120;
      else
        this.force = 160;

      let loader = new THREE.TextureLoader();
      let target = loader.load("img/alvo.jpg");
      this.mat1 = Physijs.createMaterial(new THREE.MeshPhongMaterial({map: target}), 0, 0);
      this.mat2 = Physijs.createMaterial(new THREE.MeshPhongMaterial({map: target}), 0, 0);
      this.mat3 = Physijs.createMaterial(new THREE.MeshPhongMaterial({map: target}), 0, 0);
      this.mat4 = Physijs.createMaterial(new THREE.MeshPhongMaterial({map: target}), 0, 0);

      let objetive1 = new Physijs.BoxMesh(new THREE.BoxGeometry(7.5, 10, 2.5, 1, 1, 1), this.mat1, 1);
      objetive1.applyMatrix(new THREE.Matrix4().makeTranslation(100, 7, -150));
      objetive1.receiveShadow = true;
      objetive1.autoUpdateMatrix = false;
      this.countCollisions.push(0);
      this.direction.push("left");
      this.enemies.push(objetive1);
      this.scene.add(objetive1);
      this.addBulletListener(this.enemies.length - 1);

      let objetive2 = new Physijs.BoxMesh(new THREE.BoxGeometry(7.5, 10, 2.5, 1, 1, 1), this.mat2, 1);
      objetive2.applyMatrix(new THREE.Matrix4().makeTranslation(-100, 7, -250));
      objetive2.receiveShadow = true;
      objetive2.autoUpdateMatrix = false;
      this.countCollisions.push(0);
      this.direction.push("right");
      this.enemies.push(objetive2);
      this.scene.add(objetive2);
      this.addBulletListener(this.enemies.length - 1);

      let objetive3 = new Physijs.BoxMesh(new THREE.BoxGeometry(7.5, 10, 2.5, 1, 1, 1), this.mat3, 1);
      objetive3.applyMatrix(new THREE.Matrix4().makeTranslation(100, 7, -350));
      objetive3.receiveShadow = true;
      objetive3.autoUpdateMatrix = false;
      this.countCollisions.push(0);
      this.direction.push("left");
      this.enemies.push(objetive3);
      this.scene.add(objetive3);
      this.addBulletListener(this.enemies.length - 1);

      let objetive4 = new Physijs.BoxMesh(new THREE.BoxGeometry(7.5, 10, 2.5, 1, 1, 1), this.mat4, 1);
      objetive4.applyMatrix(new THREE.Matrix4().makeTranslation(-100, 7, -450));
      objetive4.receiveShadow = true;
      objetive4.autoUpdateMatrix = false;
      this.countCollisions.push(0);
      this.direction.push("right");
      this.enemies.push(objetive4);
      this.scene.add(objetive4);
      this.addBulletListener(this.enemies.length - 1);

      return this;
    }

    addBulletListener(i) {
      let that = this;
      this.enemies[i].addEventListener('collision', function () {
        if (that.countCollisions[i] == 1) {
          scene.updateScore(10);
          that.countDead++;
          scene.actualAmmo++;
          scene.updateAmmo();
          if (that.countDead == 4) {
            scene.level++;
            scene.newLevel();
          }
        }
        that.countCollisions[i]++;
      });
    }

    getEnemies(i) {
      return this.enemies[i];
    }

    getEnemiesSize() {
      return this.enemies.length;
    }

    animate() {
      for (let i = 0; i < this.enemies.length; ++i) {
        if (this.enemies[i].position.x >= 100 && this.direction[i] == "left") {
          this.enemies[i].applyCentralImpulse(new THREE.Vector3(-this.force, 0, 0));
          this.direction[i] = "right";
        } else if (this.enemies[i].position.x <= -100 && this.direction[i] == "right") {
          this.enemies[i].applyCentralImpulse(new THREE.Vector3(this.force, 0, 0));
          this.direction[i] = "left";
        }
      }
      if (this.init) {
        this.force *= 2;
        this.init = false;
      }
    }
  }

  //Class Map Shoot Game
  class Map {
    constructor() {
      this.map_size = 0;
      this.map = [];

      //Material
      let loader = new THREE.TextureLoader();
      let texturaMetal = loader.load("img/wood3.jpg");
      let texturaBase = loader.load("img/straw2.png");
      let planeTexture = new THREE.ImageUtils.loadTexture('img/wood3.jpg');

      let mat = Physijs.createMaterial(new THREE.MeshPhongMaterial({map: texturaMetal}), 0, 0);
      let mat1 = Physijs.createMaterial(new THREE.MeshPhongMaterial({map: texturaBase}), 0, 0);
      let mat2 = Physijs.createMaterial(new THREE.MeshPhongMaterial({color: 0xfb8e00}), 0, 0);

      //Objects
      //Principal floor
      let start1 = new Physijs.BoxMesh(new THREE.BoxGeometry(1000, 0.0, 1000, 1, 1, 1), planeTexture, 0);
      start1.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0));
      start1.friction = 1000;
      start1.receiveShadow = true;
      start1.autoUpdateMatrix = false;
      this.map.push(start1);
      ++this.map_size;

      //Enemies floor
      let enemies2 = new Physijs.BoxMesh(new THREE.BoxGeometry(212, 4, 400, 1, 1, 1), mat, 0);
      enemies2.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -300));
      enemies2.receiveShadow = true;
      enemies2.autoUpdateMatrix = false;
      this.map.push(enemies2);
      ++this.map_size;

      //Bullets
      let bullets3 = new Physijs.BoxMesh(new THREE.BoxGeometry(50, 0.0, 50, 1, 1, 1), mat, 0);
      bullets3.applyMatrix(new THREE.Matrix4().makeTranslation(0, -10, 0));
      bullets3.receiveShadow = false;
      bullets3.autoUpdateMatrix = false;
      this.map.push(bullets3);
      ++this.map_size;

      //Enemies Fence
      let fenceE5 = new Physijs.BoxMesh(new THREE.BoxGeometry(10, 15, 400, 1, 1, 1), mat1, 0);
      fenceE5.applyMatrix(new THREE.Matrix4().makeTranslation(100, 2.5, 0));
      fenceE5.position.set(110, 0, -300);
      fenceE5.receiveShadow = true;
      fenceE5.autoUpdateMatrix = false;
      this.map.push(fenceE5);
      ++this.map_size;

      let fenceW6 = new Physijs.BoxMesh(new THREE.BoxGeometry(10, 15, 400, 1, 1, 1), mat1, 0);
      fenceW6.applyMatrix(new THREE.Matrix4().makeTranslation(-100, 2.5, 0));
      fenceW6.position.set(-112, 0, -300);
      fenceW6.receiveShadow = true;
      fenceW6.autoUpdateMatrix = false;
      this.map.push(fenceW6);
      ++this.map_size;

      //Invisible walls
      let invisibleS5 = new Physijs.BoxMesh(new THREE.BoxGeometry(230, 5, 2, 1, 1, 1), mat2, 0);
      invisibleS5.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 100));
      invisibleS5.position.set(0, 0, -100);
      invisibleS5.material.transparent = true;
      invisibleS5.material.opacity = 0.0;
      invisibleS5.autoUpdateMatrix = false;
      this.map.push(invisibleS5);
      ++this.map_size;

      let invisibleE5 = new Physijs.BoxMesh(new THREE.BoxGeometry(1, 150, 400, 1, 1, 1), mat2, 0);
      invisibleE5.applyMatrix(new THREE.Matrix4().makeTranslation(100, 2.5, 0));
      invisibleE5.position.set(110, 0, -300);
      invisibleE5.autoUpdateMatrix = false;
      this.map.push(invisibleE5);
      ++this.map_size;

      let invisibleE6 = new Physijs.BoxMesh(new THREE.BoxGeometry(1, 150, 400, 1, 1, 1), mat2, 0);
      invisibleE6.applyMatrix(new THREE.Matrix4().makeTranslation(-100, 2.5, 0));
      invisibleE6.position.set(-110, 0, -300);
      invisibleE6.autoUpdateMatrix = false;
      this.map.push(invisibleE6);
      ++this.map_size;

      return this;
    }

    getMap(i) {
      return this.map[i];
    }

    getMapSize() {
      return this.map_size;
    }
  }

  //Class Cloud Rain
  let cloudParticles = [], flash, rain, rainGeo, rainCount = 1500, rainDrop, rainMaterial, cloudMaterial,
    cloudGeo;

  class Cloud {
    constructor() {

      rainGeo = new THREE.Geometry();
      for (let i = 0; i < rainCount; i++) {
        rainDrop = new THREE.Vector3(
          Math.random() * 400 - 200,
          Math.random() * 1500,
          Math.random() * 1000 - 500
        );
        rainDrop.velocity = {};
        rainDrop.velocity = 0.005;
        //  rainGeo.vertices.push(rainDrop);
      }
      rainMaterial = new THREE.PointsMaterial({
        color: 0xc0c0c0,
        size: 0.5,
        transparent: true
      });
      rain = new THREE.Points(rainGeo, rainMaterial);
      scene.add(rain);

      //Cloud
      let loader = new THREE.TextureLoader();
      loader.load("img/smoke-1.png", function (texture) {

        cloudGeo = new THREE.PlaneBufferGeometry(1200, 1200);
        cloudMaterial = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,

        });

        for (let p = 0; p < 1; p++) {
          let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
          cloud.position.set(
            Math.random() * 400 - 200,
            500,
            Math.random() * 500 - 350,
          );
          cloud.rotation.x = 0.9;
          cloud.rotation.y = -0.2;
          cloud.rotation.z = Math.random() * 360;
          cloud.material.opacity = 5.5;
          cloudParticles.push(cloud);
          scene.add(cloud);
        }
      });
    }

    update() {
      cloudParticles.forEach(p => {
        p.rotation.z -= 0.0005;
      });
      rainGeo.vertices.forEach(p => {
        p.velocity -= 0.001 + Math.random() * 0.001;
        p.y += p.velocity;
        if (p.y < -200) {
          p.y = 200;
          p.velocity = 0;
        }
      });
      rainGeo.verticesNeedUpdate = true;
      rain.rotation.y += 0.0002;
    }
  }


  //Class Aplication
  let camera, scene, renderer, controls;
  const objects = [];
  stats = null;
  mouseDown = false;
  controls = null;
  moveForward = false;
  moveBackward = false;
  moveLeft = false;
  moveRight = false;
  shooting = false;
  enableControls = true;

  function createGUI(withStats) {
    let gui = new dat.GUI();
    if (withStats) stats = initStats();
  }


  function initStats() {
    let stats = new Stats();
    stats.setMode(0); // 0: fps, 1: ms
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    $("#Stats-output").append(stats.domElement);
    return stats;
  }

  function setMessage(str) {
    document.getElementById("Messages").innerHTML = "<h2>" + str + "</h2>";
  }

  //Principal Scene
  class Application {
    constructor() {
      this.createScene();
      this.objects = [];
    }

    createScene() {
      let width = window.innerWidth;
      let height = window.innerHeight;
      let aspect = width / height;

      'use strict';
      Physijs.scripts.worker = 'js/physijs_worker.js';

      //Scene
      scene = new TheScene();

      //Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 20, 0);

      //Render
      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(width, height);
      document.body.appendChild(renderer.domElement);

      //SkyBox
      const tloader = new THREE.CubeTextureLoader();
      tloader.setPath('img/');
      let textureCube = tloader.load([
        "nightsky_ft.png",
        'nightsky_bk.png',
        'nightsky_up.png',
        'nightsky_dn.png',
        'nightsky_rt.png',
        'nightsky_lf.png',
      ]);
      scene.background = textureCube;

      //Plane
      let planeTexture = new THREE.ImageUtils.loadTexture('img/Grass.jpg')
      planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
      planeTexture.repeat.set(50, 50);
      let planeGeometry = new THREE.PlaneBufferGeometry(1000, 1000, 100, 100);
      let planeMaterial = new THREE.MeshPhongMaterial({
        color: new THREE.Color('#21451b'),
        specular: new THREE.Color('#122b01'),
        shininess: 10,
        bumpMap: planeTexture
      });

      let plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.set(-Math.PI / 2, 0, 0);
      plane.position.set(0, 0, 0);
      plane.receiveShadow = true;
      scene.add(plane);

      // Catch resize events
      addEventListener("resize", () => {
        width = innerWidth
        height = innerHeight
        renderer.setSize(width, height)
        camera.aspect = width / height
        camera.updateProjectionMatrix()
      })

      //Light
      renderer.shadowMapEnabled = true;
      renderer.shadowMapSoft = true;
      let light = new THREE.DirectionalLight(0xf2f3f4);
      light.position.set(-500, 250, 500).normalize(2);

      //Shadow
      light.castShadow = true;
      light.shadowDarkness = 0.5;
      light.shadow.camera.left = -500;
      light.shadow.camera.right = 500;
      light.shadow.camera.top = 500;
      light.shadow.camera.bottom = -500;
      light.shadow.camera.near = 1;
      light.shadow.camera.far = 1000;
      light.shadowCameraVisible = true;
      light.shadow.mapSize.width = 512;
      light.shadow.mapSize.height = 512;
      scene.add(light);

      //Light2
      let light2 = new THREE.AmbientLight(0xf0f8ff, 0.4);
      light2.position.set(150, 100, -150).normalize();
      scene.add(light2);

      /*
            //Axes Helper
            // show axes in the screen
            let axes = new THREE.AxesHelper(200);
            scene.add(axes);
            */

      // House
      let mtl = new THREE.MTLLoader();
      mtl.setPath("models/");
      mtl.load('WoodenCabinObj.mtl', function (materials) {

        materials.preload();
        let obj = new THREE.OBJLoader();
        obj.setMaterials(materials);
        obj.setPath("models/");
        obj.load('WoodenCabinObj.obj', function (object) {

          let mesh = object;
          mesh.position.x = 150;
          mesh.position.y = 0;
          mesh.position.z = -50;
          mesh.rotation.y = 4.8;
          mesh.castShadow = true;
          scene.add(mesh);
        });
      });


      //LockerSpace -Controls
      controls = new THREE.PointerLockControls(camera);
      scene.add(controls.getObject());
      createGUI(true);

      let instructions = document.getElementById('instructions');
      let havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

      if (havePointerLock) {
        let element = document.body;
        let pointerlockchange = function (event) {
          if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
            controlsEnabled = true;
            controls.enabled = true;
            enableControls = true;
            blocker.style.display = 'none';
          } else {
            blocker.style.display = 'block';
            instructions.style.display = '';

            instructions.style.fontSize = "50px";
            instructions.innerHTML = "PAUSA";
            enableControls = false;
            controls.enabled = false;
          }
        };

        let pointerlockerror = function (event) {
          instructions.style.display = '';
        };
        // Hook pointer lock state change events
        document.addEventListener('pointerlockchange', pointerlockchange, false);
        document.addEventListener('mozpointerlockchange', pointerlockchange, false);
        document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

        document.addEventListener('pointerlockerror', pointerlockerror, false);
        document.addEventListener('mozpointerlockerror', pointerlockerror, false);
        document.addEventListener('webkitpointerlockerror', pointerlockerror, false);

        instructions.addEventListener('click', function (event) {
          instructions.style.display = 'none';
          // Ask the browser to lock the pointer
          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
          element.requestPointerLock();
        }, false);
      }

      let controlsEnabled = false;
      document.body.addEventListener("mousedown", function (event) {
        if (enableControls) {
          if (event.buttons == 1 && blocker.style.display == 'none') {
            scene.shoot();
            shooting = true;
          }
        }
      });


      document.body.addEventListener("keydown", function (event) {
        if (enableControls) {
          switch (event.keyCode) {

            case 38: // up
            case 87: // w
              moveForward = true;
              break;

            case 37: // left
            case 65: // a
              moveLeft = true;
              break;

            case 40: // down
            case 83: // s
              moveBackward = true;
              break;

            case 39: // right
            case 68: // d
              moveRight = true;
              break;

          }
        }

      });

      document.body.addEventListener("keyup", function (event) {

        if (enableControls) {
          switch (event.keyCode) {

            case 38: // up
            case 87: // w
              moveForward = false;
              break;

            case 37: // left
            case 65: // a
              moveLeft = false;
              break;

            case 40: // down
            case 83: // s
              moveBackward = false;
              break;

            case 39: // right
            case 68: // d
              moveRight = false;
              break;

          }
        }
        if (event.keyCode == 80 && enableControls == false) { // p
          scene.newGame();
        }
      });
    }

    //Render the scene with camera
    render() {
      renderer.render(scene, camera);
    }

    add(mesh) {
      let index;
      if (Array.isArray(mesh)) {
        for (index in mesh) {
          this.objects.push(mesh[index]);
          scene.add(mesh[index].getMesh());
        }
      } else {
        this.objects.push(mesh);
        scene.add(mesh.getMesh());
      }
    }

    loop() {
      requestAnimationFrame(() => this.loop());
      this.objects.forEach((object) => object.update());
      this.render();
      scene.animate();
      stats.update();
    }

    //Loop Game
    start() {
      this.loop();
    }
  }

  //Physijs Scene
  class TheScene extends Physijs.Scene {
    constructor(renderer, aCamera) {

      super();
      this.setGravity(new THREE.Vector3(0, -50, 0));
      this.camera = aCamera;
      this.Person = null;
      this.map = null;
      this.enemies = null;
      this.index = 0;
      this.maxBullets = 20;
      this.actualAmmo = 40;
      this.score = 0;
      this.lastScore = 0;
      this.level = 1;
      this.createHUD();
      this.createPerson();
      this.Person.loadWeapons();
      this.place = this.createPlace();
      this.createBullets();
      this.createEnemies(this.level);
      this.add(this.place);
    }

    createEnemies() {
      this.enemies = new Enemies(this, this.level);
    }

    createBullets() {
      this.bullets = new Bullets(this.maxBullets, this, (new THREE.MeshPhongMaterial({color: 0xfb8e00})));
    }


    createPlace() {
      let place = new THREE.Object3D();
      this.map = new Map();
      for (let i = 0; i < this.map.getMapSize(); ++i) {
        this.add(this.map.getMap(i));
      }
      return place;
    }

    createPerson() {
      this.Person = new Person(camera, this);
    }

    getCameraControls() {
      return this.controls;
    }

    createHUD() {
      let score = document.createElement('div');
      score.id = "score";
      score.style.position = 'absolute';
      score.style.width = 1;
      score.style.height = 1;
      score.innerHTML = "Score: " + this.score;
      score.style.top = 60 + 'px';
      score.style.left = 50 + 'px';
      score.style.fontSize = 20 + 'px';
      score.style.color = "white";
      document.body.appendChild(score);

      let ammo = document.createElement('div');
      ammo.id = "ammo";
      ammo.style.position = 'absolute';
      ammo.style.width = 1;
      ammo.style.height = 1;
      ammo.innerHTML = " " + this.actualAmmo;
      ammo.style.top = 495 + 'px';
      ammo.style.right = 250 + 'px';
      ammo.style.fontSize = 20 + 'px';
      ammo.style.color = "white";
      ammo.style.rotate = '90';
      document.body.appendChild(ammo);

      let level = document.createElement('div');
      level.id = "level";
      level.style.position = 'absolute';
      level.style.width = 1;
      level.style.height = 1;
      level.innerHTML = "Level: " + this.level;
      level.style.top = 100 + 'px';
      level.style.left = 50 + 'px';
      level.style.fontSize = 20 + 'px';
      level.style.color = "white";
      document.body.appendChild(level);
    }

    endGame() {
      enableControls = false;
      controls.enabled = false;
      moveForward = false;
      moveBackward = false;
      moveLeft = false;
      moveRight = false;
      blocker.style.display = 'block';
      instructions.style.display = '';
      instructions.style.fontSize = "20px";
      instructions.innerHTML = "Score Total : " + this.score + ", pressione P para novo jogo!";
    }

    shoot() {
      if (this.index >= this.maxBullets) {
        this.index = 0;
        this.bullets.reload();
      }
      if (!shooting) {
        this.bullets.shoot(this.index, this.Person.getPosition(), camera.getWorldDirection(), this.Person.getActiveWeapon());
        this.index++;
        this.actualAmmo--;
        this.updateAmmo();
      }
    }

    animate() {
      this.simulate();
      if (moveForward) this.Person.moveForward();
      if (moveBackward) this.Person.moveBackward();
      if (moveLeft) this.Person.moveLeft();
      if (moveRight) this.Person.moveRight();
      if (shooting) {
        this.Person.animateWeapon();
      }

      this.Person.updateControls();
      this.enemies.animate();
      if (this.actualAmmo == 0) {
        this.endGame();
      }
    }

    getCameraControls() {
      return this.controls;
    }

    updateAmmo() {
      let text = document.getElementById("ammo");
      text.innerHTML = " " + this.actualAmmo;
    }

    updateScore(newScore) {
      let text = document.getElementById("score");
      this.score += newScore;
      text.innerHTML = "Score: " + this.score;
    }

    updateLevel() {
      let level = document.getElementById("level");
      level.innerHTML = "Nivel: " + this.level;
    }

    newGame() {
      blocker.style.display = 'none';
      enableControls = true;
      controls.enabled = true;
      this.Person.setInitialPosition();
      this.actualAmmo = 40;
      this.updateAmmo();
      this.score = 0;
      this.updateScore(0);
      this.level = 1;
      this.updateLevel();
      for (let i = 0; i < this.enemies.getEnemiesSize(); ++i) {
        this.remove(this.enemies.getEnemies(i));
      }
      this.createEnemies();
    }

    newLevel() {
      this.Person.setInitialPosition();

      if (this.score - this.lastScore != 40)
        this.score = this.lastScore + 40;
      this.updateLevel();
      for (let i = 0; i < this.enemies.getEnemiesSize(); ++i) {
        this.remove(this.enemies.getEnemies(i));
      }
      this.createEnemies();
      this.lastScore = this.score;
    }
  }


  //Objects Input
  let app;
  window.onload = function () {
    app = new Application();

    //Fence
    let fence = [
      new Fence({x: 109, y: 0, z: -99}, {y: 0}),
      new Fence({x: 98, y: 0, z: -99}, {y: 0}),
      new Fence({x: 87, y: 0, z: -99}, {y: 0}),
      new Fence({x: 76, y: 0, z: -99}, {y: 0}),
      new Fence({x: 65, y: 0, z: -99}, {y: 0}),
      new Fence({x: 54, y: 0, z: -99}, {y: 0}),
      new Fence({x: 43, y: 0, z: -99}, {y: 0}),
      new Fence({x: 32, y: 0, z: -99}, {y: 0}),
      new Fence({x: 21, y: 0, z: -99}, {y: 0}),
      new Fence({x: 10, y: 0, z: -99}, {y: 0}),
      new Fence({x: -1, y: 0, z: -99}, {y: 0}),
      new Fence({x: -12, y: 0, z: -99}, {y: 0}),
      new Fence({x: -23, y: 0, z: -99}, {y: 0}),
      new Fence({x: -34, y: 0, z: -99}, {y: 0}),
      new Fence({x: -45, y: 0, z: -99}, {y: 0}),
      new Fence({x: -56, y: 0, z: -99}, {y: 0}),
      new Fence({x: -67, y: 0, z: -99}, {y: 0}),
      new Fence({x: -78, y: 0, z: -99}, {y: 0}),
      new Fence({x: -89, y: 0, z: -99}, {y: 0}),
      new Fence({x: -100, y: 0, z: -99}, {y: 0}),
      new Fence({x: -111, y: 0, z: -99}, {y: 0}),


      new Fence({x: 130, y: 0, z: 16}, {y: 0}),
      new Fence({x: 119, y: 0, z: 16}, {y: 0}),
      new Fence({x: 108, y: 0, z: 16}, {y: 0}),
      new Fence({x: 102.5, y: 0, z: 21.5}, {y: 4.7}),
      new Fence({x: 102.5, y: 0, z: 32.45}, {y: 4.7}),
      new Fence({x: 102.5, y: 0, z: 43.5}, {y: 4.7}),
      new Fence({x: 135.4, y: 0, z: 21.5}, {y: 4.7}),
      new Fence({x: 135.2, y: 0, z: 32.45}, {y: 4.7}),
      new Fence({x: 135.0, y: 0, z: 43.5}, {y: 4.7}),
    ];
    app.add(fence);


    //Straw
    let straw = [
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 2, z: 20}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 2, z: 26}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 2, z: 32}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 2, z: 38}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 7, z: 23}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 7, z: 29}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 7, z: 35}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 12, z: 26}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 12, z: 32}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 125, y: 17, z: 29}, {y: 0}),
      new CubeTexture({width: 10, height: 5, depth: 5}, {x: 110, y: 2, z: 29}, {y: 10}),
    ];
    app.add(straw);

    /*
    //Trees
    for(let i=0;i<25;i++){
      let  objs = new Tree( {x: ((( Math.random() * 1000 - 500 ) /50)*50+25) , y: 0, z:((( Math.random() * 1000 - 500 ) /50)*50+25)})
      app.add(objs);
    }*/

    //Reference Tree
    app.add(new Tree({x: 10, y: 0, z: 140}));
    app.add(new Tree({x: 200, y: 0, z: -100}));
    app.add(new Tree({x: -420, y: 0, z: -150}));
    app.add(new Tree({x: 180, y: 0, z: 70}));
    app.add(new Tree({x: -200, y: 0, z: -200}));
    app.add(new Tree({x: -150, y: 0
      , z: -150}));

    //Loop Start
    app.start();

    //Raining Cloud
    app.add(new Cloud());
  }

</script>
</body>
</html>
</script>
</body>
</html>
